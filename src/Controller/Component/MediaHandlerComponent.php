<?php
/**
 * Created by PhpStorm.
 * User: finleysiebert
 * Date: 16-02-18
 * Time: 21:57
 */

namespace App\Controller\Component;


use App\Model\Entity\Media;
use Cake\Controller\Component;
use Cake\Core\Configure;
use Cake\Filesystem\File;
use Cake\Filesystem\Folder;
use Cake\Log\Log;
use claviska\SimpleImage;
use FFMpeg\Coordinate\FrameRate;
use FFMpeg\Coordinate\TimeCode;
use FFMpeg\FFMpeg;
use FFMpeg\Format\Audio\Mp3;
use FFMpeg\Format\Video\WebM;
use FFMpeg\Format\Video\X264;

/**
 * Class MediaHandlerComponent
 * @package App\Controller\Component
 * @property FFMpeg _ffmpeg
 */
class MediaHandlerComponent extends Component
{
    /**
     * @var array
     */
    private $_allowedMedias;

    /**
     * @var
     */
    private $_ffmpeg;
    private $_watermarkPath = ROOT . DS . 'webroot' . DS . 'img' . DS . 'watermerk.png';

    /**
     * @param array $config
     */
    public function initialize(array $config)
    {
        parent::initialize($config); // TODO: Change the autogenerated stub
        $this->_ffmpeg = FFMPEG::create([
            'ffmpeg.binaries' => '/usr/local/bin/ffmpeg',
            'ffprobe.binaries' => '/usr/local/bin/ffprobe'
        ]);
        $this->_allowedMedias = Configure::read('Files.allowed_content_types');

    }

    /**
     * @param Media $media
     * @param $tmpFile
     */
    public function processAudio(Media $media, $tmpFile) {

        move_uploaded_file($tmpFile, ROOT . DS . 'media' . DS . 'raw' . DS . $media->filename . '.' . $media->extension);

        if ($media->extension != 'mp3') {
            $audio = $this->_ffmpeg->open(ROOT . DS . 'media' . DS . 'raw' . DS . $media->filename . '.' . $media->extension);
            $audio
                ->save(new Mp3(), ROOT . DS . 'media' . DS . 'audio' . DS . $media->filename . '.mp3');

        }
        else
        {
            $file = new File(ROOT . DS . 'media' . DS . 'raw' . DS . $media->filename . '.mp3');
            $file->copy(ROOT . DS . 'media' . DS . 'audio' . DS . $media->filename . '.mp3');
        }

        $this->_cleanRaw();

    }

    /**
     * @param Media $media
     * @param $tmpFile
     */
    public function processImage(Media $media, $tmpFile)
    {
        move_uploaded_file($tmpFile, ROOT . DS . 'media' . DS . 'raw' . DS . $media->filename . '.' . $media->extension);

        if($media->extension != 'gif') {
            try {
                $image = (new SimpleImage())

                    ->fromFile(ROOT . DS . 'media' . DS . 'raw' . DS . $media->filename . '.' . $media->extension)
                    ->autoOrient()
                    ->bestFit(600, 400)
                    ->overlay($this->_watermarkPath, 'bottom right')
                    ->toFile(ROOT . DS . 'media' . DS . 'images' . DS . $media->filename . '.png', 'image/png', 70);


            }
            catch (\Exception $e) {
                die($e->getMessage());
            }
        }
        else
        {
            try {
            $image = (new SimpleImage())
                ->fromFile(ROOT . DS . 'media' . DS . 'raw' . DS . $media->filename . '.' . $media->extension)
                ->autoOrient()
                ->bestFit(600, 400)
                ->overlay($this->_watermarkPath, 'bottom right')
                ->toFile(ROOT . DS . 'media' . DS . 'images' . DS . $media->filename . '.' . $media->extension, 'image/png', 50);
            }
            catch(\Exception $e) {
                die($e->getMessage());
            }
        }

        $this->_cleanRaw();
    }

    public function processVideo(Media $media, $tmpFile)
    {
        move_uploaded_file($tmpFile, ROOT . DS . 'media' . DS . 'raw' . DS . $media->filename . '.' . $media->extension);
        $video = $this->_ffmpeg->open(ROOT . DS . 'media' . DS . 'raw' . DS . $media->filename . '.' . $media->extension);

        $video->filters()
            ->watermark($this->_watermarkPath, [
                'position' => 'relative',
                'bottom' => 10,
                'right' => 10
            ])->synchronize();

        $video
            ->frame(TimeCode::fromSeconds(1))
            ->save(ROOT . DS . 'media' . DS . 'thumbnails' . DS . 'thumb_' . $media->filename . '.png');

        switch ($media->extension) {

            case 'mp4':
                $video->save(new X264(), ROOT . DS . 'media' . DS . 'videos' . DS . 'mp4' . DS . $media->filename . '.mp4');

                break;

            case 'webm':
                $format = new X264();

                $video
                    ->save($format, ROOT . DS . 'media' . DS . 'videos' . DS . 'mp4' . DS . $media->filename . '.mp4');

            default:
                $video
                    ->save(new X264(), ROOT . DS . 'media' . DS . 'videos' . DS . 'mp4' . DS . $media->filename . '.mp4')
                    ->save(new WebM(), ROOT . DS . 'media' . DS . 'videos' . DS . 'webm' . DS . $media->filename . '.webm');
                break;
        }


        $this->_cleanRaw();
    }

    /**
     * @param Media $media
     * @return bool
     */
    public function isMediaAllowed(Media $media)
    {
        return in_array($media->content_type, $this->_allowedMedias);
    }

    protected function _cleanRaw() {
        $folder = new Folder(ROOT . DS . 'media' . DS . 'raw', false);
        foreach($folder->find() as $file) {
            $f = new File(ROOT . DS . 'media' . DS . 'raw' . DS .  $file);
            $f->delete();
        }

        Log::info('Raw folder has been cleared');
    }

    public function isMediaTooBig(Media $media) {
        return ($media->size > Configure::read('Files.max_uploadsize'));
    }
}